{-# LANGUAGE OverloadedStrings #-}

module CSVImport
    ( importCSVs
    ) where

import Turtle
import Prelude hiding (FilePath, putStrLn)
import Data.Text (breakOn)
import Data.Text.IO (putStrLn)
import Data.Maybe
import Common

docURL :: Line
docURL = "https://github.com/apauley/hledger-makeitso#how-to-use-it"

importCSVs :: FilePath -> IO ()
importCSVs baseDir = do
  let importDir = baseDir </> "import"
  importExists <- testdir importDir
  if importExists
    then
    do
      let importedJournals = importBanks $ lsDirs importDir
      sh $ writeMakeItSoJournal baseDir importedJournals
    else
    do
      let msg = format ("I couldn't find a directory named \"import\" underneath "%fp
                        %"\n\nhledger-makitso expects to find its input files in specifically\nnamed directories.\n\n"%
                        "Have a look at the documentation for a detailed explanation:\n"%l) baseDir docURL
      stderr $ select $ textToLines msg
      exit $ ExitFailure 1

writeMakeItSoJournal :: FilePath -> Shell FilePath -> Shell ()
writeMakeItSoJournal baseDir importedJournals = do
  let importAggregateJournal = baseDir </> "import-all.journal"
  writeJournals importAggregateJournal importedJournals
  let manualDir = baseDir </> "manual"
  let pre = manualDir </> "pre-import.journal"
  let post = manualDir </> "post-import.journal"
  mktree manualDir
  touch pre
  touch post
  let makeitsoJournal = baseDir </> "makeitso.journal"
  writeJournals' dontSort makeitsoJournal $ select [pre, importAggregateJournal, post]

writeJournals :: FilePath -> Shell FilePath -> Shell ()
writeJournals = writeJournals' sort

writeJournals' :: (Shell FilePath -> Shell [FilePath]) -> FilePath -> Shell FilePath -> Shell ()
writeJournals' sortFun aggregateJournal journals = do
  let journalBaseDir = directory aggregateJournal
  liftIO $ writeTextFile aggregateJournal "### Generated by hledger-makeitso - DO NOT EDIT ###\n\n"
  journalFiles <- sortFun journals
  journalFile <- uniq $ select journalFiles
  let strippedJournal = fromMaybe journalFile $ stripPrefix journalBaseDir journalFile
  liftIO $ append aggregateJournal $ toIncludeLines $ return $ strippedJournal

writeJournalsUnsorted :: FilePath -> Shell FilePath -> (Shell FilePath -> Shell [FilePath]) -> Shell ()
writeJournalsUnsorted aggregateJournal journals sortFun = do
  let journalBaseDir = directory aggregateJournal
  liftIO $ writeTextFile aggregateJournal "### Generated by hledger-makeitso - DO NOT EDIT ###\n\n"
  journalFiles <- sortFun journals
  journalFile <- uniq $ select journalFiles
  let strippedJournal = fromMaybe journalFile $ stripPrefix journalBaseDir journalFile
  liftIO $ append aggregateJournal $ toIncludeLines $ return $ strippedJournal

toIncludeLines :: Shell FilePath -> Shell Line
toIncludeLines paths = do
  journalFile <- paths
  return $ fromMaybe "" $ textToLine $ format ("!include "%fp) journalFile

importBanks :: Shell FilePath -> Shell FilePath
importBanks bankDirs = do
  bankDir <- bankDirs
  bankName <- basenameLine bankDir
  let bankJournals = importAccounts bankName $ lsDirs bankDir
  let aggregateJournal = bankDir </> buildFilename [bankName] "journal"
  writeJournals aggregateJournal bankJournals
  return aggregateJournal

importAccounts :: Line -> Shell FilePath -> Shell FilePath
importAccounts bankName accountDirs = do
  accDir <- accountDirs
  accName <- basenameLine accDir
  let defaultRulesFile = accDir </> buildFilename [bankName, accName] "rules"
  let preprocessScript = accDir </> fromText "preprocess"
  let importScript = accDir </> fromText "import"
  let accountSrcFiles = onlyFiles $ find (has (text "1-in")) accDir
  let accJournals = importAccountFiles bankName accName defaultRulesFile preprocessScript importScript accountSrcFiles
  let aggregateJournal = accDir </> buildFilename [bankName, accName] "journal"
  let openingJournal = accDir </> "opening.journal"
  liftIO $ touch openingJournal
  writeJournals aggregateJournal $ (return openingJournal) + accJournals
  return aggregateJournal

importAccountFiles :: Line -> Line -> FilePath -> FilePath -> FilePath -> Shell FilePath -> Shell FilePath
importAccountFiles bankName accountName defaultRulesFile preprocessScript importScript accountSrcFiles = do
  srcFile <- accountSrcFiles
  csvFile <- preprocessIfNeeded preprocessScript bankName accountName srcFile
  doCustomImort <- testfile importScript
  let importFun = if doCustomImort
        then customImport importScript bankName accountName
        else hledgerImport defaultRulesFile
  let journalOut = changePathAndExtension "3-journal" "journal" csvFile
  mktree $ directory journalOut
  importFun csvFile journalOut

preprocessIfNeeded :: FilePath -> Line -> Line -> FilePath -> Shell FilePath
preprocessIfNeeded script bank account src = do
  shouldPreprocess <- testfile script
  if shouldPreprocess
    then preprocess script bank account src
    else return src

preprocess :: FilePath -> Line -> Line -> FilePath -> Shell FilePath
preprocess script bank account src = do
  let csvOut = changePathAndExtension "2-preprocessed" "csv" src
  mktree $ directory csvOut
  let script' = format fp script :: Text
  procs script' [format fp src, format fp csvOut, lineToText bank, lineToText account] empty
  return csvOut

hledgerImport :: FilePath -> FilePath -> FilePath -> Shell FilePath
hledgerImport defaultRulesFile csvSrc journalOut = do
  rf <- rulesFile csvSrc defaultRulesFile
  rulesFileExists <- testfile rf
  if rulesFileExists
    then
    do
      procs "hledger" ["print", "--rules-file", format fp rf, "--file", format fp csvSrc, "--output-file", format fp journalOut] empty
      return journalOut
    else
    do
      let msg = format ("I couldn't find an hledger rules file at\n"%fp
                        %"\n\nhledger-makitso looks for a rules file in a select few places.\n\n"%
                        "The documentation will tell you everything you need to know:\n"%l) rf docURL
      stderr $ select $ textToLines msg
      exit $ ExitFailure 1

customImport :: FilePath -> Line -> Line -> FilePath -> FilePath -> Shell FilePath
customImport importScript bank account csvSrc journalOut = do
  let script = format fp importScript :: Text
  let importOut = inproc script [format fp csvSrc, "-", lineToText bank, lineToText account] empty
  procs "hledger" ["print", "--ignore-assertions", "--file", "-", "--output-file", format fp journalOut] importOut
  return journalOut

rulesFile :: FilePath -> FilePath -> Shell FilePath
rulesFile csvSrc defaultRulesFile = do
  let srcPrefix = fst $ breakOn "_" (format fp (basename csvSrc))
  let srcSpecificFilename = fromText srcPrefix <.> "rules"
  srcSpecificFile <- searchUp 2 ((parent . parent . parent) csvSrc) srcSpecificFilename
  case srcSpecificFile of
    Just file -> return file
    Nothing   -> return defaultRulesFile

changePathAndExtension :: FilePath -> Text -> FilePath -> FilePath
changePathAndExtension newOutputLocation newExt = (changeOutputPath newOutputLocation) . (changeExtension newExt)

changeExtension :: Text -> FilePath -> FilePath
changeExtension extension path = (dropExtension path) <.> extension

changeOutputPath :: FilePath -> FilePath -> FilePath
changeOutputPath newOutputLocation srcFile = mconcat $ map changeSrcDir $ splitDirectories srcFile
  where changeSrcDir f = if (f == "1-in/" || f == "2-preprocessed/") then newOutputLocation else f
