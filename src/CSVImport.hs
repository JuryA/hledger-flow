{-# LANGUAGE OverloadedStrings #-}

module CSVImport
    ( importCSVs
    ) where

import Turtle
import Prelude hiding (FilePath, putStrLn)
import Data.Text (breakOn)
import Data.Text.IO (putStrLn)
import Data.Maybe
import Common

importCSVs :: FilePath -> IO ()
importCSVs baseDir = do
  let importDir = baseDir </> "import"
  importExists <- testdir importDir
  let journals = if importExists
        then importBanks $ lsDirs importDir
        else die $ format ("Unable to find CSV import dir at "%fp) importDir
  sh $ writeJournals (baseDir </> "import-all.journal") journals

writeJournals :: FilePath -> Shell FilePath -> Shell ()
writeJournals aggregateJournal journals = do
  let journalBaseDir = directory aggregateJournal
  liftIO $ writeTextFile aggregateJournal "### Generated by hledger-makeitso - DO NOT EDIT ###\n\n"
  journalFiles <- sort journals
  journalFile <- uniq $ select journalFiles
  let strippedJournal = fromMaybe journalFile $ stripPrefix journalBaseDir journalFile
  liftIO $ append aggregateJournal $ toIncludeLines $ return $ strippedJournal

toIncludeLines :: Shell FilePath -> Shell Line
toIncludeLines paths = do
  journalFile <- paths
  return $ fromMaybe "" $ textToLine $ format ("!include "%fp) journalFile

importBanks :: Shell FilePath -> Shell FilePath
importBanks bankDirs = do
  bankDir <- bankDirs
  bankName <- basenameLine bankDir
  let bankJournals = importAccounts bankName $ lsDirs bankDir
  let aggregateJournal = bankDir </> buildFilename [bankName] "journal"
  writeJournals aggregateJournal bankJournals
  return aggregateJournal

importAccounts :: Line -> Shell FilePath -> Shell FilePath
importAccounts bankName accountDirs = do
  accDir <- accountDirs
  accName <- basenameLine accDir
  let defaultRulesFile = accDir </> buildFilename [bankName, accName] "rules"
  let preprocessScript = accDir </> fromText "preprocess"
  let accountSrcFiles = onlyFiles $ find (has (text "1-in")) accDir
  let accJournals = importAccountFiles bankName accName defaultRulesFile preprocessScript accountSrcFiles
  let aggregateJournal = accDir </> buildFilename [bankName, accName] "journal"
  let equityJournal = accDir </> "opening-closing.journal"
  liftIO $ touch equityJournal
  writeJournals aggregateJournal $ (return equityJournal) + accJournals
  return aggregateJournal

importAccountFiles :: Line -> Line -> FilePath -> FilePath -> Shell FilePath -> Shell FilePath
importAccountFiles bankName accountName defaultRulesFile preprocessScript accountSrcFiles = do
  srcFile <- accountSrcFiles
  csvFile <- preprocessIfNeeded preprocessScript bankName accountName srcFile
  hledgerImport csvFile defaultRulesFile

preprocessIfNeeded :: FilePath -> Line -> Line -> FilePath -> Shell FilePath
preprocessIfNeeded script bank account src = do
  shouldPreprocess <- testfile script
  if shouldPreprocess
    then preprocess script bank account src
    else return src

preprocess :: FilePath -> Line -> Line -> FilePath -> Shell FilePath
preprocess script bank account src = do
  let csvOut = changePathAndExtension "2-preprocessed" "csv" src
  mktree $ directory csvOut
  let script' = format fp script :: Text
  procs script' [lineToText bank, lineToText account, format fp src, format fp csvOut] empty
  return csvOut

hledgerImport :: FilePath -> FilePath -> Shell FilePath
hledgerImport csvSrc defaultRulesFile = do
  let journalOut = changePathAndExtension "3-journal" "journal" csvSrc
  mktree $ directory journalOut
  rf <- rulesFile csvSrc defaultRulesFile
  procs "hledger" ["print", "--rules-file", format fp rf, "--file", format fp csvSrc, "--output-file", format fp journalOut] empty
  return journalOut

rulesFile :: FilePath -> FilePath -> Shell FilePath
rulesFile csvSrc defaultRulesFile = do
  let srcPrefix = fst $ breakOn "_" (format fp (basename csvSrc))
  let srcSpecificFilename = fromText srcPrefix <.> "rules"
  srcSpecificFile <- searchUp 2 ((parent . parent . parent) csvSrc) srcSpecificFilename
  case srcSpecificFile of
    Just file -> return file
    Nothing   -> return defaultRulesFile

changePathAndExtension :: FilePath -> Text -> FilePath -> FilePath
changePathAndExtension newOutputLocation newExt = (changeOutputPath newOutputLocation) . (changeExtension newExt)

changeExtension :: Text -> FilePath -> FilePath
changeExtension extension path = (dropExtension path) <.> extension

changeOutputPath :: FilePath -> FilePath -> FilePath
changeOutputPath newOutputLocation srcFile = mconcat $ map changeSrcDir $ splitDirectories srcFile
  where changeSrcDir f = if (f == "1-in/" || f == "2-preprocessed/") then newOutputLocation else f
